---
title: "Rust中的所有权初体验"
date: "2023-01-11 15:20:55"
author: "干徒"
tags: ["Rust"]
---

所有权系统是Rust中的一大特点
今日靓仔我啊，就来体验一番  

我们先来看一段代码
```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // s1 的所有权转移给了 s2
    println!("s1: {}, s2: {}", s1, s2); // 报错，s1 已经被移动了
}
```
***你可能不了解rust代码，那么按照你熟悉的语言去理解他，大同小异***

代码中先定义了一个String字符串类型的变量 `s1`  

然后紧接着定义了一个变量 `s2`，此时需要注意，`s2` 的值是由 `s1` 赋值所得（可以先简单理解为赋值）
然后打印出 `s1`，`s2` 发现报错了  

问题就出现在 `let s2 = s1;` 这段代码，这里其实发生了所有权转移，也就是 `s1` 的所有权发生了向 `s2` 转移  

那么 `s1` 变量在所有权发生转移后，再进行访问，那么在rust中将是不合法的访问



如果不需要所有权转移，而只是简单的拷贝，则可以使用clone函数

```rust
fn main() {
    let mut s1 = String::from("hello");
    let s2 = s1.clone(); // 深拷贝
    println!("s1: {}, s2: {}", s1, s2);
    s1.push_str(" world"); // 修改 s1
    println!("s1: {}, s2: {}", s1, s2); // s2 的值没有改变，说明是深拷贝
}
```

以上代码，通过对 `s1` 进行修改，会发现 `s2` 没有被一同修改，说明 `clone()` 函数是深拷贝

体验了rust中的所有权，很奇妙，像进了米奇妙妙屋...